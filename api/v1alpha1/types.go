// Copyright Contributors to the KubeOpenCode project

// Package v1alpha1 contains the v1alpha1 API definitions
package v1alpha1

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ContextType defines the type of context source
// +kubebuilder:validation:Enum=Text;ConfigMap;Git;Runtime;URL
type ContextType string

const (
	// ContextTypeText represents text content defined directly in YAML.
	ContextTypeText ContextType = "Text"

	// ContextTypeConfigMap represents content from a ConfigMap
	ContextTypeConfigMap ContextType = "ConfigMap"

	// ContextTypeGit represents content from a Git repository
	ContextTypeGit ContextType = "Git"

	// ContextTypeRuntime represents KubeOpenCode platform awareness context.
	// When enabled, the controller injects a system prompt that explains
	// the runtime environment to the agent.
	ContextTypeRuntime ContextType = "Runtime"

	// ContextTypeURL represents content fetched from a remote HTTP/HTTPS URL.
	// The content is fetched at task execution time via an init container.
	//
	// Use cases:
	//   - Remote API specifications (OpenAPI, GraphQL schemas)
	//   - External documentation or guidelines
	//   - Dynamic configuration from external services
	ContextTypeURL ContextType = "URL"
)

// ConfigMapContext references a ConfigMap for context content.
type ConfigMapContext struct {
	// Name of the ConfigMap
	// +required
	Name string `json:"name"`

	// Key specifies a single key to mount as a file.
	// If not specified, all keys are mounted as files in the directory.
	// +optional
	Key string `json:"key,omitempty"`

	// Optional specifies whether the ConfigMap must exist.
	// +optional
	Optional *bool `json:"optional,omitempty"`
}

// GitContext references content from a Git repository.
type GitContext struct {
	// Repository is the Git repository URL.
	// Example: "https://github.com/org/contexts"
	// +required
	Repository string `json:"repository"`

	// Path is the path within the repository to mount.
	// Can be a file or directory. If empty, the entire repository is mounted.
	//
	// Note on .git directory:
	//   - If Path is empty (entire repo): The mounted directory WILL contain .git/
	//   - If Path is specified (subdirectory): The mounted directory will NOT contain .git/
	//
	// Example: ".claude/", "docs/guide.md"
	// +optional
	Path string `json:"path,omitempty"`

	// Ref is the Git reference (branch, tag, or commit SHA).
	// Defaults to "HEAD" if not specified.
	// +optional
	// +kubebuilder:default="HEAD"
	Ref string `json:"ref,omitempty"`

	// Depth specifies the clone depth for shallow cloning.
	// 1 means shallow clone (fastest), 0 means full clone.
	// Defaults to 1 for efficiency.
	// +optional
	// +kubebuilder:default=1
	Depth *int `json:"depth,omitempty"`

	// SecretRef references a Secret containing Git credentials.
	// The Secret should contain one of:
	//   - "username" + "password": For HTTPS token-based auth (password can be a PAT)
	//   - "ssh-privatekey": For SSH key-based auth
	// If not specified, anonymous clone is attempted.
	// +optional
	SecretRef *GitSecretReference `json:"secretRef,omitempty"`
}

// GitSecretReference references a Secret for Git authentication.
type GitSecretReference struct {
	// Name of the Secret containing Git credentials.
	// +required
	Name string `json:"name"`
}

// RuntimeContext enables KubeOpenCode platform awareness for agents.
// When enabled, the controller injects a system prompt that explains:
//   - The agent is running in a Kubernetes environment as a KubeOpenCode Task
//   - Available environment variables (TASK_NAME, TASK_NAMESPACE, WORKSPACE_DIR)
//   - How to query Task/Workflow information via kubectl
//   - Understanding of task.md structure and context mounting
//
// This context type has no configurable fields - the content is generated
// by the controller at runtime.
type RuntimeContext struct {
	// No fields - content is generated by the controller
}

// URLContext references content from a remote HTTP/HTTPS URL.
// The content is fetched at task execution time via an init container.
type URLContext struct {
	// Source is the URL to fetch content from.
	// Must be a valid HTTP or HTTPS URL.
	// +required
	Source string `json:"source"`

	// Headers specifies HTTP headers to include in the request.
	// Useful for authentication tokens or custom headers.
	// Example: {"Authorization": "Bearer token123"}
	// +optional
	Headers map[string]string `json:"headers,omitempty"`

	// SecretRef references a Secret containing authentication credentials.
	// The Secret can contain:
	//   - "token": Used as Bearer token in Authorization header
	//   - "username" + "password": Used for HTTP Basic authentication
	// If both Headers["Authorization"] and SecretRef are specified,
	// SecretRef takes precedence.
	// +optional
	SecretRef *URLSecretReference `json:"secretRef,omitempty"`

	// InsecureSkipTLSVerify skips TLS certificate verification.
	// WARNING: This is insecure and should only be used for testing
	// or with self-signed certificates in controlled environments.
	// +optional
	InsecureSkipTLSVerify bool `json:"insecureSkipTLSVerify,omitempty"`

	// Timeout specifies the request timeout in seconds.
	// Defaults to 30 seconds if not specified.
	// +optional
	// +kubebuilder:default=30
	Timeout *int32 `json:"timeout,omitempty"`
}

// URLSecretReference references a Secret for URL authentication.
type URLSecretReference struct {
	// Name of the Secret containing authentication credentials.
	// +required
	Name string `json:"name"`
}

// ContextItem defines context with content and mount path.
// Used directly in Task/Agent specs to provide additional context for task execution.
type ContextItem struct {
	// === Common Fields ===

	// Name is an optional identifier for this context.
	// Used for:
	//   - Logging and debugging (clearer error messages)
	//   - XML tag generation (appears in task.md context blocks)
	//   - Context deduplication (same-named contexts can override each other)
	// If not specified, a default name is generated based on the context type and index.
	// +optional
	Name string `json:"name,omitempty"`

	// Description provides human-readable documentation for this context.
	// This is purely for documentation purposes and does not affect behavior.
	// Useful for explaining why a context is included or what it provides.
	// +optional
	Description string `json:"description,omitempty"`

	// Optional specifies whether this context is required for task execution.
	// If true, the task will proceed even if the context cannot be resolved
	// (e.g., ConfigMap not found, Git clone failed, URL fetch failed).
	// If false (default), the task will fail if the context cannot be resolved.
	//
	// Note: This field takes precedence over type-specific optional fields
	// (e.g., configMap.optional). If both are specified, this field wins.
	// +optional
	Optional *bool `json:"optional,omitempty"`

	// === Type and Mount Configuration ===

	// Type of context source: Text, ConfigMap, Git, Runtime, Secret, or URL
	// +required
	Type ContextType `json:"type"`

	// MountPath specifies where this context should be mounted in the agent pod.
	//
	// Path resolution follows Tekton conventions:
	// - Absolute paths (starting with "/") are used as-is
	// - Relative paths (NOT starting with "/") are prefixed with the agent's workspaceDir
	//
	// If not specified, the content is appended to task.md with XML tags.
	//
	// Note: For Runtime context type, MountPath is ignored - content is always
	// appended to task.md.
	// +optional
	MountPath string `json:"mountPath,omitempty"`

	// FileMode is the file permission mode for the mounted file (e.g., 0755 for executable scripts).
	// Only applicable when MountPath is specified.
	// If not specified, defaults to 0644.
	// +optional
	FileMode *int32 `json:"fileMode,omitempty"`

	// === Type-Specific Fields ===

	// Text is the text content (required when Type == "Text").
	// Contains text content defined directly in YAML.
	// +optional
	Text string `json:"text,omitempty"`

	// ConfigMap context (required when Type == "ConfigMap")
	// +optional
	ConfigMap *ConfigMapContext `json:"configMap,omitempty"`

	// Git context (required when Type == "Git")
	// +optional
	Git *GitContext `json:"git,omitempty"`

	// Runtime context (optional when Type == "Runtime")
	// Enables KubeOpenCode platform awareness. The controller injects a system prompt
	// that explains the runtime environment to the agent.
	// +optional
	Runtime *RuntimeContext `json:"runtime,omitempty"`

	// URL context (required when Type == "URL")
	// Fetches content from a remote HTTP/HTTPS URL at task execution time.
	// +optional
	URL *URLContext `json:"url,omitempty"`
}

// TaskPhase represents the current phase of a task
// +kubebuilder:validation:Enum=Pending;Queued;Running;Completed;Failed
type TaskPhase string

const (
	// TaskPhasePending means the task has not started yet
	TaskPhasePending TaskPhase = "Pending"
	// TaskPhaseQueued means the task is waiting for Agent capacity.
	// This occurs when the Agent has maxConcurrentTasks set and the limit is reached.
	// The task will automatically transition to Running when capacity becomes available.
	TaskPhaseQueued TaskPhase = "Queued"
	// TaskPhaseRunning means the task is currently executing
	TaskPhaseRunning TaskPhase = "Running"
	// TaskPhaseCompleted means the task execution finished (Job exited with code 0).
	// This indicates the agent completed its work, not necessarily that the task "succeeded".
	// The actual outcome should be determined by examining the agent's output.
	TaskPhaseCompleted TaskPhase = "Completed"
	// TaskPhaseFailed means the task had an infrastructure failure
	// (e.g., Job crashed, unable to schedule, missing Agent).
	TaskPhaseFailed TaskPhase = "Failed"
)

const (
	// ConditionTypeReady is the condition type for Task readiness
	ConditionTypeReady = "Ready"
	// ConditionTypeQueued is the condition type for Task queuing
	ConditionTypeQueued = "Queued"
	// ConditionTypeStopped is the condition type for Task stop
	ConditionTypeStopped = "Stopped"

	// ReasonTaskTemplateError is the reason for TaskTemplate errors
	ReasonTaskTemplateError = "TaskTemplateError"
	// ReasonAgentError is the reason for Agent errors
	ReasonAgentError = "AgentError"
	// ReasonAgentAtCapacity is the reason for Agent capacity limit
	ReasonAgentAtCapacity = "AgentAtCapacity"
	// ReasonQuotaExceeded is the reason for Agent quota limit
	ReasonQuotaExceeded = "QuotaExceeded"
	// ReasonContextError is the reason for Context errors
	ReasonContextError = "ContextError"
	// ReasonUserStopped is the reason for user-initiated stop
	ReasonUserStopped = "UserStopped"
	// ReasonNoLimits is the reason for no limits configured
	ReasonNoLimits = "NoLimits"
	// ReasonCapacityAvailable is the reason for capacity availability
	ReasonCapacityAvailable = "CapacityAvailable"
)

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope="Namespaced",shortName=tk
// +kubebuilder:printcolumn:JSONPath=`.status.phase`,name="Phase",type=string
// +kubebuilder:printcolumn:JSONPath=`.status.podName`,name="Pod",type=string
// +kubebuilder:printcolumn:JSONPath=`.metadata.creationTimestamp`,name="Age",type=date

// Task represents a single task execution.
// Task is the primary API for users who want to execute AI-powered tasks.
type Task struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// Spec defines the desired state of Task
	Spec TaskSpec `json:"spec"`

	// Status represents the current status of the Task
	// +optional
	Status TaskExecutionStatus `json:"status,omitempty"`
}

// AgentReference specifies which Agent to use for task execution.
// Supports cross-namespace references to enable separation of concerns:
// - Platform teams manage Agents with credentials in dedicated namespaces
// - Dev teams create Tasks in their own namespaces, referencing shared Agents
type AgentReference struct {
	// Name of the Agent.
	// +required
	Name string `json:"name"`

	// Namespace of the Agent.
	// If empty, defaults to the Task's namespace.
	// When specified, the Pod runs in the Agent's namespace (not the Task's namespace),
	// allowing credentials to stay isolated from Task creators.
	// +optional
	Namespace string `json:"namespace,omitempty"`
}

// TaskSpec defines the Task configuration
type TaskSpec struct {
	// TaskTemplateRef references a TaskTemplate to use as base configuration.
	// The template's settings are merged with this Task's settings.
	//
	// When using a template:
	//   - TaskTemplate.agentRef is used if Task.agentRef is not specified
	//   - TaskTemplate.contexts are prepended to Task.contexts
	//   - TaskTemplate.outputs are merged with Task.outputs (Task takes precedence)
	//   - TaskTemplate.description is used if Task.description is not specified
	//
	// Example:
	//   taskTemplateRef:
	//     name: pr-task-template
	//     namespace: platform-templates
	// +optional
	TaskTemplateRef *TaskTemplateReference `json:"taskTemplateRef,omitempty"`

	// Description is the task instruction/prompt.
	// The controller creates ${WORKSPACE_DIR}/task.md with this content
	// (where WORKSPACE_DIR is configured in Agent.spec.workspaceDir, defaulting to "/workspace").
	// This is the primary way to tell the agent what to do.
	//
	// If taskTemplateRef is specified and description is not set,
	// the template's description is used.
	//
	// Example:
	//   description: "Update all dependencies and create a PR"
	// +optional
	Description *string `json:"description,omitempty"`

	// Contexts provides additional context for the task.
	// Contexts are processed in array order, with later contexts taking precedence.
	//
	// Context priority (lowest to highest):
	//   1. Agent.contexts (Agent-level defaults)
	//   2. TaskTemplate.contexts (Template-level defaults, if taskTemplateRef is set)
	//   3. Task.contexts (Task-specific contexts)
	//   4. Task.description (highest, becomes ${WORKSPACE_DIR}/task.md)
	//
	// Example:
	//   contexts:
	//     - type: Text
	//       text: "Always use conventional commits"
	//     - type: Git
	//       mountPath: src
	//       git:
	//         repository: https://github.com/org/repo
	//         ref: main
	// +optional
	Contexts []ContextItem `json:"contexts,omitempty"`

	// AgentRef references an Agent for this task.
	// Supports cross-namespace references: when Agent is in a different namespace,
	// the Pod runs in the Agent's namespace to keep credentials isolated.
	//
	// If not specified and taskTemplateRef is set, uses the template's agentRef.
	// If neither is specified, uses the "default" Agent in the same namespace.
	// +optional
	AgentRef *AgentReference `json:"agentRef,omitempty"`

	// Outputs defines output parameters to capture from this Task.
	// The controller creates a sidecar to capture these outputs from files.
	//
	// If taskTemplateRef is specified, outputs are merged with the template's outputs.
	// Task outputs take precedence for same-named parameters.
	//
	// Example:
	//   outputs:
	//     parameters:
	//       - name: pr-url
	//         path: ".outputs/pr-url"
	//       - name: summary
	//         path: ".outputs/summary"
	//         default: "No summary provided"
	// +optional
	Outputs *OutputSpec `json:"outputs,omitempty"`
}

// TaskExecutionStatus defines the observed state of Task
type TaskExecutionStatus struct {
	// ObservedGeneration is the most recent generation observed by the controller.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`

	// Execution phase
	// +optional
	Phase TaskPhase `json:"phase,omitempty"`

	// Kubernetes Pod name
	// +optional
	PodName string `json:"podName,omitempty"`

	// PodNamespace indicates where the Pod is running.
	// This may differ from Task's namespace when using cross-namespace Agent reference.
	// When Agent is in a different namespace, the Pod runs in the Agent's namespace
	// to keep credentials isolated from Task creators.
	// +optional
	PodNamespace string `json:"podNamespace,omitempty"`

	// Start time
	// +optional
	StartTime *metav1.Time `json:"startTime,omitempty"`

	// Completion time
	// +optional
	CompletionTime *metav1.Time `json:"completionTime,omitempty"`

	// Outputs contains results captured from task execution.
	// This is populated when the task completes (either success or failure).
	// +optional
	Outputs *TaskOutputs `json:"outputs,omitempty"`

	// Kubernetes standard conditions
	// +optional
	// +listType=map
	// +listMapKey=type
	Conditions []metav1.Condition `json:"conditions,omitempty"`
}

// TaskOutputs contains parameters captured from task execution files.
// The output-collector sidecar reads files specified in OutputSpec and
// writes the captured values to the Pod's termination message.
//
// Size limits (due to Kubernetes termination message 4KB limit):
//   - Total JSON output: max 4KB
//   - For larger outputs, consider using external storage (future feature)
type TaskOutputs struct {
	// Parameters is a key-value map of outputs captured from files.
	// Keys are defined in Task.spec.outputs.
	// Values are read from the corresponding file paths by the sidecar.
	//
	// Example usage:
	//   kubectl get task my-task -o jsonpath='{.status.outputs.parameters.pr-url}'
	// +optional
	Parameters map[string]string `json:"parameters,omitempty"`
}

// OutputSpec defines output parameters to capture from task execution.
type OutputSpec struct {
	// Parameters defines the output parameters to capture from files.
	// Each parameter specifies a name and file path to read from.
	// +optional
	Parameters []OutputParameterSpec `json:"parameters,omitempty"`
}

// OutputParameterSpec defines a single output parameter to capture from a file.
type OutputParameterSpec struct {
	// Name is the parameter name, used as the key in status.outputs.parameters.
	// Must be unique within the output parameters.
	// +required
	Name string `json:"name"`

	// Path is the file path to read the parameter value from.
	// Relative paths are prefixed with workspaceDir.
	// Example: ".outputs/pr-url" -> ${WORKSPACE_DIR}/.outputs/pr-url
	// +required
	Path string `json:"path"`

	// Default is the default value if the file doesn't exist.
	// If not specified and file doesn't exist, parameter is omitted from output.
	// +optional
	Default *string `json:"default,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TaskList contains a list of Task
type TaskList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Task `json:"items"`
}

// TaskTemplateReference specifies which TaskTemplate to use.
// Supports cross-namespace references to enable sharing templates across namespaces.
type TaskTemplateReference struct {
	// Name of the TaskTemplate.
	// +required
	Name string `json:"name"`

	// Namespace of the TaskTemplate.
	// If empty, defaults to the Task's namespace.
	// +optional
	Namespace string `json:"namespace,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:scope="Namespaced",shortName=tt
// +kubebuilder:printcolumn:JSONPath=`.spec.agentRef.name`,name="Agent",type=string
// +kubebuilder:printcolumn:JSONPath=`.metadata.creationTimestamp`,name="Age",type=date

// TaskTemplate defines a reusable template for Task creation.
// TaskTemplates allow users to define common Task configurations (contexts, outputs, agentRef)
// that can be shared across multiple Tasks. Similar to Argo WorkflowTemplate.
type TaskTemplate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// Spec defines the template configuration
	Spec TaskTemplateSpec `json:"spec"`
}

// TaskTemplateSpec defines the template for Task creation.
// It contains all TaskSpec fields that can be shared across multiple Tasks.
type TaskTemplateSpec struct {
	// Description is the default task instruction/prompt.
	// Can be overridden by Task.spec.description.
	// If Task doesn't specify description, this value is used.
	// +optional
	Description *string `json:"description,omitempty"`

	// AgentRef references an Agent for tasks using this template.
	// Can be overridden by Task.spec.agentRef.
	// +optional
	AgentRef *AgentReference `json:"agentRef,omitempty"`

	// Contexts provides default contexts for tasks using this template.
	// These are merged with Task.spec.contexts (Task contexts appended after template contexts).
	//
	// Context priority (lowest to highest):
	//   1. Agent.contexts (Agent-level defaults)
	//   2. TaskTemplate.contexts (Template-level defaults)
	//   3. Task.contexts (Task-specific contexts)
	//   4. Task.description (highest, becomes ${WORKSPACE_DIR}/task.md)
	// +optional
	Contexts []ContextItem `json:"contexts,omitempty"`

	// Outputs defines default output parameters for tasks using this template.
	// Parameters are merged with Task.spec.outputs (Task takes precedence for same-named params).
	// +optional
	Outputs *OutputSpec `json:"outputs,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TaskTemplateList contains a list of TaskTemplate
type TaskTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TaskTemplate `json:"items"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope="Namespaced",shortName=ag
// +kubebuilder:printcolumn:JSONPath=`.spec.agentImage`,name="Image",type=string,priority=1
// +kubebuilder:printcolumn:JSONPath=`.spec.serviceAccountName`,name="ServiceAccount",type=string
// +kubebuilder:printcolumn:JSONPath=`.metadata.creationTimestamp`,name="Age",type=date

// Agent defines the AI agent configuration for task execution.
// Agent = AI agent + permissions + tools + infrastructure
// This is the execution black box - Task creators don't need to understand execution details.
type Agent struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// Spec defines the agent configuration
	Spec AgentSpec `json:"spec"`

	// Status represents the current status of the Agent
	// +optional
	Status AgentStatus `json:"status,omitempty"`
}

// QuotaConfig defines rate limiting for Task starts within a sliding time window.
// This is different from maxConcurrentTasks which limits concurrent running Tasks.
// Quota limits the RATE at which new Tasks can start.
type QuotaConfig struct {
	// MaxTaskStarts is the maximum number of Task starts allowed within the window.
	// +kubebuilder:validation:Minimum=1
	// +required
	MaxTaskStarts int32 `json:"maxTaskStarts"`

	// WindowSeconds defines the sliding window duration in seconds.
	// For example, 3600 (1 hour) means "max N tasks per hour".
	// +kubebuilder:validation:Minimum=60
	// +kubebuilder:validation:Maximum=86400
	// +required
	WindowSeconds int32 `json:"windowSeconds"`
}

// TaskStartRecord represents a record of a Task start for quota tracking.
// Stored in AgentStatus to persist across controller restarts.
type TaskStartRecord struct {
	// TaskName is the name of the Task that was started.
	TaskName string `json:"taskName"`

	// TaskNamespace is the namespace of the Task.
	TaskNamespace string `json:"taskNamespace"`

	// StartTime is when the Task transitioned to Running phase.
	StartTime metav1.Time `json:"startTime"`
}

// AgentSpec defines agent configuration
type AgentSpec struct {
	// AgentImage specifies the OpenCode init container image.
	// This image contains the OpenCode binary that gets copied to /tools volume.
	// The init container runs this image and copies the opencode binary to /tools/opencode.
	// If not specified, defaults to "quay.io/kubeopencode/kubeopencode-agent-opencode:latest".
	// +optional
	AgentImage string `json:"agentImage,omitempty"`

	// ExecutorImage specifies the main worker container image for task execution.
	// This is the development environment where tasks actually run.
	// The container uses /tools/opencode (provided by agentImage init container) to execute AI tasks.
	// If not specified, defaults to "quay.io/kubeopencode/kubeopencode-agent-devbox:latest".
	// +optional
	ExecutorImage string `json:"executorImage,omitempty"`

	// WorkspaceDir specifies the working directory inside the agent container.
	// This is where task.md and context files are mounted.
	// The agent image must support the WORKSPACE_DIR environment variable.
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern=`^/.*`
	// +kubebuilder:validation:MinLength=1
	WorkspaceDir string `json:"workspaceDir"`

	// Command specifies the entrypoint command for the agent container.
	// This is optional and overrides the default ENTRYPOINT of the container image.
	//
	// If not specified, defaults to:
	//   ["sh", "-c", "/tools/opencode run \"$(cat ${WORKSPACE_DIR}/task.md)\""]
	//
	// The command defines HOW the agent executes tasks. Most users should not
	// need to customize this. Override only if you need custom execution behavior.
	//
	// ## Example
	//
	//   command: ["sh", "-c", "/tools/opencode run --format json \"$(cat /workspace/task.md)\""]
	//
	// +optional
	Command []string `json:"command,omitempty"`

	// Contexts provides default contexts for all tasks using this Agent.
	// These have the lowest priority in context merging.
	//
	// Context priority (lowest to highest):
	//   1. Agent.contexts (Agent-level defaults)
	//   2. Task.contexts (Task-specific contexts)
	//   3. Task.description (highest, becomes ${WORKSPACE_DIR}/task.md)
	//
	// Use this for organization-wide defaults like coding standards, security policies,
	// or common tool configurations that should apply to all tasks.
	// +optional
	Contexts []ContextItem `json:"contexts,omitempty"`

	// Config provides OpenCode configuration as a JSON string.
	// This configuration is written to /tools/opencode.json and the OPENCODE_CONFIG
	// environment variable is set to point to this file.
	//
	// The config should be a valid JSON object compatible with OpenCode's config schema.
	// See: https://opencode.ai/config.json for the schema.
	//
	// Example:
	//   config: |
	//     {
	//       "$schema": "https://opencode.ai/config.json",
	//       "model": "google/gemini-2.5-pro",
	//       "small_model": "google/gemini-2.5-flash"
	//     }
	// +optional
	Config *string `json:"config,omitempty"`

	// Credentials defines secrets that should be available to the agent.
	// Similar to GitHub Actions secrets, these can be mounted as files or
	// exposed as environment variables.
	//
	// Example use cases:
	//   - GitHub token for repository access (env: GITHUB_TOKEN)
	//   - SSH keys for git operations (file: ~/.ssh/id_rsa)
	//   - API keys for external services (env: ANTHROPIC_API_KEY)
	//   - Cloud credentials (file: ~/.config/gcloud/credentials.json)
	// +optional
	Credentials []Credential `json:"credentials,omitempty"`

	// PodSpec defines advanced Pod configuration for agent pods.
	// This includes labels, scheduling, runtime class, and other Pod-level settings.
	// Use this for fine-grained control over how agent pods are created.
	// +optional
	PodSpec *AgentPodSpec `json:"podSpec,omitempty"`

	// ServiceAccountName specifies the Kubernetes ServiceAccount to use for agent pods.
	// This controls what cluster resources the agent can access via RBAC.
	//
	// The ServiceAccount must exist in the Agent's namespace (where Pods run).
	// Users are responsible for creating the ServiceAccount and appropriate RBAC bindings
	// based on what permissions their agent needs.
	//
	// +required
	ServiceAccountName string `json:"serviceAccountName"`

	// AllowedNamespaces restricts which namespaces can reference this Agent.
	// This enables platform teams to control access to shared Agents.
	//
	// Supports glob patterns (e.g., "team-*", "prod-*", "dev-frontend").
	// Empty list means all namespaces are allowed (default: open to all).
	//
	// When a Task in namespace "foo" references this Agent and "foo" doesn't
	// match any pattern, the controller rejects the Task with an error condition.
	//
	// Example:
	//   allowedNamespaces:
	//     - "prod-*"      # All production namespaces
	//     - "staging"     # Staging namespace
	//     - "team-alpha"  # Specific team namespace
	// +optional
	AllowedNamespaces []string `json:"allowedNamespaces,omitempty"`

	// MaxConcurrentTasks limits the number of Tasks that can run concurrently
	// using this Agent. When the limit is reached, new Tasks will enter Queued
	// phase until capacity becomes available.
	//
	// This is useful when the Agent uses backend AI services with rate limits
	// (e.g., Claude, Gemini API quotas) to prevent overwhelming the service.
	//
	// - nil or 0: unlimited (default behavior, no concurrency limit)
	// - positive number: maximum number of Tasks that can be in Running phase
	//
	// Example:
	//   maxConcurrentTasks: 3  # Only 3 Tasks can run at once
	// +optional
	MaxConcurrentTasks *int32 `json:"maxConcurrentTasks,omitempty"`

	// Quota defines rate limiting for Task starts within a sliding time window.
	// When configured, Tasks will be queued if the quota is exceeded.
	// This is complementary to maxConcurrentTasks:
	//   - maxConcurrentTasks: limits how many Tasks run at once
	//   - quota: limits how quickly new Tasks can start
	//
	// Example:
	//   quota:
	//     maxTaskStarts: 10
	//     windowSeconds: 3600  # 10 tasks per hour
	// +optional
	Quota *QuotaConfig `json:"quota,omitempty"`
}

// AgentStatus defines the observed state of Agent
type AgentStatus struct {
	// ObservedGeneration is the most recent generation observed by the controller.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`

	// Conditions represent the latest available observations of the Agent's state.
	// +optional
	// +listType=map
	// +listMapKey=type
	Conditions []metav1.Condition `json:"conditions,omitempty"`

	// TaskStartHistory tracks recent Task starts for quota enforcement.
	// The controller prunes entries older than the quota window automatically.
	// This is only populated when quota is configured on the Agent.
	// +optional
	// +listType=atomic
	TaskStartHistory []TaskStartRecord `json:"taskStartHistory,omitempty"`
}

// AgentPodSpec defines advanced Pod configuration for agent pods.
// This groups all Pod-level settings that control how the agent container runs.
type AgentPodSpec struct {
	// Labels defines additional labels to add to the agent pod.
	// These labels are applied to the Job's pod template and enable integration with:
	//   - NetworkPolicy podSelector for network isolation
	//   - Service selector for service discovery
	//   - PodMonitor/ServiceMonitor for Prometheus monitoring
	//   - Any other label-based pod selection
	//
	// Example: To make pods match a NetworkPolicy with podSelector:
	//   labels:
	//     network-policy: agent-restricted
	// +optional
	Labels map[string]string `json:"labels,omitempty"`

	// Scheduling defines pod scheduling configuration for agent pods.
	// This includes node selection, tolerations, and affinity rules.
	// +optional
	Scheduling *PodScheduling `json:"scheduling,omitempty"`

	// RuntimeClassName specifies the RuntimeClass to use for agent pods.
	// RuntimeClass provides a way to select container runtime configurations
	// such as gVisor (runsc) or Kata Containers for enhanced isolation.
	//
	// This is useful when running untrusted AI agent code that may generate
	// and execute arbitrary commands. Using gVisor or Kata provides an
	// additional layer of security beyond standard container isolation.
	//
	// The RuntimeClass must exist in the cluster before use.
	// Common values: "gvisor", "kata", "runc" (default if not specified)
	//
	// Example:
	//   runtimeClassName: gvisor
	//
	// See: https://kubernetes.io/docs/concepts/containers/runtime-class/
	// +optional
	RuntimeClassName *string `json:"runtimeClassName,omitempty"`
}

// PodScheduling defines scheduling configuration for agent pods.
// All fields are applied directly to the Job's pod template.
type PodScheduling struct {
	// NodeSelector specifies a selector for scheduling pods to specific nodes.
	// The pod will only be scheduled to nodes that have all the specified labels.
	//
	// Example:
	//   nodeSelector:
	//     kubernetes.io/os: linux
	//     node-type: gpu
	// +optional
	NodeSelector map[string]string `json:"nodeSelector,omitempty"`

	// Tolerations allows pods to be scheduled on nodes with matching taints.
	//
	// Example:
	//   tolerations:
	//     - key: "dedicated"
	//       operator: "Equal"
	//       value: "ai-workload"
	//       effect: "NoSchedule"
	// +optional
	Tolerations []corev1.Toleration `json:"tolerations,omitempty"`

	// Affinity specifies affinity and anti-affinity rules for pods.
	// This enables advanced scheduling based on node attributes, pod co-location,
	// or pod anti-affinity for high availability.
	//
	// Example:
	//   affinity:
	//     nodeAffinity:
	//       requiredDuringSchedulingIgnoredDuringExecution:
	//         nodeSelectorTerms:
	//           - matchExpressions:
	//               - key: topology.kubernetes.io/zone
	//                 operator: In
	//                 values: ["us-west-2a", "us-west-2b"]
	// +optional
	Affinity *corev1.Affinity `json:"affinity,omitempty"`
}

// Credential represents a secret that should be available to the agent.
// Each credential references a Kubernetes Secret and specifies how to expose it.
//
// Mounting behavior depends on whether SecretRef.Key is specified:
//
// 1. No Key specified + No MountPath: entire Secret as environment variables
// 2. No Key specified + MountPath: entire Secret as directory (each key becomes a file)
// 3. Key specified + Env: single key as environment variable
// 4. Key specified + MountPath: single key as file
type Credential struct {
	// Name is a descriptive name for this credential (for documentation purposes).
	// +required
	Name string `json:"name"`

	// SecretRef references the Kubernetes Secret containing the credential.
	// +required
	SecretRef SecretReference `json:"secretRef"`

	// MountPath specifies where to mount the secret.
	// - If SecretRef.Key is specified: mounts the single key's value as a file at this path.
	//   Example: "/home/agent/.ssh/id_rsa" for SSH keys
	// - If SecretRef.Key is not specified: mounts the entire Secret as a directory,
	//   where each key in the Secret becomes a file in the directory.
	//   Example: "/etc/ssl/certs" for a Secret containing ca.crt, client.crt, client.key
	// +optional
	MountPath *string `json:"mountPath,omitempty"`

	// Env specifies the environment variable name to expose the secret value.
	// Only applicable when SecretRef.Key is specified.
	// If specified, the secret key's value is set as this environment variable.
	// Example: "GITHUB_TOKEN" for GitHub API access
	// +optional
	Env *string `json:"env,omitempty"`

	// FileMode specifies the permission mode for mounted files.
	// Only applicable when MountPath is specified.
	// Defaults to 0600 (read/write for owner only) for security.
	// Use 0400 for read-only files like SSH keys.
	// +optional
	FileMode *int32 `json:"fileMode,omitempty"`
}

// SecretReference references a Kubernetes Secret.
// When Key is specified, only that specific key is used.
// When Key is omitted, the entire Secret is used (behavior depends on Credential.MountPath).
type SecretReference struct {
	// Name of the Secret.
	// +required
	Name string `json:"name"`

	// Key of the Secret to select.
	// If not specified, the entire Secret is used:
	// - With MountPath: mounted as a directory (each key becomes a file)
	// - Without MountPath: all keys become environment variables
	// When Key is omitted, the Env field on the Credential is ignored.
	// +optional
	Key *string `json:"key,omitempty"`
}

// ConfigMapKeySelector selects a key of a ConfigMap.
type ConfigMapKeySelector struct {
	// Name of the ConfigMap
	// +required
	Name string `json:"name"`

	// Key of the ConfigMap to select from
	// +required
	Key string `json:"key"`

	// Specify whether the ConfigMap must be defined
	// +optional
	Optional *bool `json:"optional,omitempty"`
}

// ConfigMapReference references an entire ConfigMap.
// Used with DirPath to mount all keys as files in a directory.
type ConfigMapReference struct {
	// Name of the ConfigMap
	// +required
	Name string `json:"name"`

	// Specify whether the ConfigMap must be defined
	// +optional
	Optional *bool `json:"optional,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// AgentList contains a list of Agent
type AgentList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Agent `json:"items"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:scope="Namespaced",shortName=ktc
// +kubebuilder:printcolumn:JSONPath=`.metadata.creationTimestamp`,name="Age",type=date

// KubeOpenCodeConfig defines system-level configuration for KubeOpenCode.
// This CRD provides cluster or namespace-level settings for the KubeOpenCode system.
type KubeOpenCodeConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// Spec defines the KubeOpenCode configuration
	Spec KubeOpenCodeConfigSpec `json:"spec"`
}

// KubeOpenCodeConfigSpec defines the system-level configuration
type KubeOpenCodeConfigSpec struct {
	// SystemImage configures the KubeOpenCode system image used for internal components
	// such as git-init and context-init containers.
	// If not specified, uses the built-in default image with IfNotPresent policy.
	// +optional
	SystemImage *SystemImageConfig `json:"systemImage,omitempty"`

	// Cleanup configures automatic cleanup of completed Tasks.
	// When configured, completed/failed Tasks are automatically deleted based on
	// TTL (time-to-live) and/or retention count policies.
	// If not specified, Tasks are not automatically deleted (default behavior).
	// +optional
	Cleanup *CleanupConfig `json:"cleanup,omitempty"`
}

// CleanupConfig defines cleanup policies for completed/failed Tasks.
// Both TTL and retention-based cleanup can be configured independently or combined.
// When both are configured, TTL is checked first, then retention count.
type CleanupConfig struct {
	// TTLSecondsAfterFinished specifies the TTL for cleaning up finished Tasks.
	// If set, completed/failed Tasks will be deleted after this duration from CompletionTime.
	// If unset or nil, TTL-based cleanup is disabled.
	//
	// Example:
	//   ttlSecondsAfterFinished: 3600  # Delete after 1 hour
	// +optional
	// +kubebuilder:validation:Minimum=0
	TTLSecondsAfterFinished *int32 `json:"ttlSecondsAfterFinished,omitempty"`

	// MaxRetainedTasks specifies the maximum number of completed/failed Tasks to retain
	// per namespace. When exceeded, the oldest Tasks (by CompletionTime) are deleted first.
	// If unset or nil, retention-based cleanup is disabled.
	//
	// Note: TTL cleanup takes precedence - Tasks exceeding TTL are deleted regardless
	// of this limit. This count only applies to Tasks that haven't exceeded TTL yet.
	//
	// Example:
	//   maxRetainedTasks: 100  # Keep at most 100 completed Tasks
	// +optional
	// +kubebuilder:validation:Minimum=0
	MaxRetainedTasks *int32 `json:"maxRetainedTasks,omitempty"`
}

// SystemImageConfig configures the KubeOpenCode system image used for internal components
// such as git-init and context-init containers.
type SystemImageConfig struct {
	// Image specifies the system image to use for internal KubeOpenCode components.
	// If not specified, defaults to the built-in DefaultKubeOpenCodeImage.
	// Example: "quay.io/kubeopencode/kubeopencode:v0.2.0"
	// +optional
	Image string `json:"image,omitempty"`

	// ImagePullPolicy specifies the image pull policy for the system image.
	// Defaults to IfNotPresent if not specified.
	// +optional
	// +kubebuilder:validation:Enum=Always;Never;IfNotPresent
	ImagePullPolicy corev1.PullPolicy `json:"imagePullPolicy,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// KubeOpenCodeConfigList contains a list of KubeOpenCodeConfig
type KubeOpenCodeConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []KubeOpenCodeConfig `json:"items"`
}
